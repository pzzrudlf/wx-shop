{"version":3,"sources":["matrix.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*! Matrix v0.0.0 | https://github.com/angusgibbs/matrix/blob/master/LICENSE */\r\n(function() {\r\n\t// Public: Creates a new Matrix object.\r\n\t//\r\n\t// data - A two dimensional array of the matrix contents.\r\n\t//\r\n\t// Throws an error if `data` is not a valid two-dimensional numeric array.\r\n\t// Returns a new Matrix object.\r\n\tvar Matrix = function(data) {\r\n\t\t// Check if the matrix was just given a row and column value - if so,\r\n\t\t// create an all zero matrix with the specified dimensions.\r\n\t\tvar args = arguments;\r\n\t\tif (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {\r\n\t\t\t// Store the dimensions\r\n\t\t\tthis.rows = args[0];\r\n\t\t\tthis.cols = args[1];\r\n\r\n\t\t\t// Set all indices to 0\r\n\t\t\tthis._setData(function() {\r\n\t\t\t\treturn 0;\r\n\t\t\t});\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Throw an error if `data` is not an array\r\n\t\tif (!Array.isArray(data)) {\r\n\t\t\tthrowError('Array must be passed');\r\n\t\t}\r\n\r\n\t\t// Store a reference to this\r\n\t\tvar thiz = this;\r\n\r\n\t\t// Store the matrix rows\r\n\t\tthiz.rows = data.length;\r\n\r\n\t\t// Store the data onto the matrix object\r\n\t\tdata.forEach(function(row, rowNum) {\r\n\t\t\t// Throw an error if the row is not an array\r\n\t\t\tif (!Array.isArray(row)) {\r\n\t\t\t\tthrowError('The array passed must be a two-dimensional array');\r\n\t\t\t}\r\n\r\n\t\t\t// Store the matrix cols if it hasn't been stored\r\n\t\t\tif (!thiz.cols) {\r\n\t\t\t\tthiz.cols = row.length;\r\n\t\t\t}\r\n\r\n\t\t\t// Initialize an array at the row number\r\n\t\t\tthiz[rowNum] = [];\r\n\r\n\t\t\trow.forEach(function(col, colNum) {\r\n\t\t\t\t// Throw an error if the column is not a number\r\n\t\t\t\tif (typeof col !== 'number') {\r\n\t\t\t\t\tthrowError('The matrix fields must be numeric');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Store the column onto the matrix object\r\n\t\t\t\tthiz[rowNum][colNum] = col;\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\r\n\t// Public: Determines whether errors should be thrown on bad data.\r\n\t//\r\n\t// Default: false.\r\n\tMatrix.silent = false;\r\n\r\n\t// Internal: Creates a new matrix without the specified row or column.\r\n\t//\r\n\t// excludeRow - The row to exclude.\r\n\t// excludeCol - The column to exclude.\r\n\t//\r\n\t// Returns the new matrix.\r\n\tMatrix.prototype._submatrix = function(excludeRow, excludeCol) {\r\n\t\t// Create an array that will be used to initialize the new matrix\r\n\t\tvar data = [];\r\n\r\n\t\t// Go through each of the rows\r\n\t\tfor (var i = 0, row = 0; i < this.rows; i++) {\r\n\t\t\t// Skip if it's the row to exclude\r\n\t\t\tif (i === excludeRow) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Initialize an array for the current column\r\n\t\t\tdata[row] = [];\r\n\r\n\t\t\t// Go through each of the columns\r\n\t\t\tfor (var j = 0, col = 0; j < this.cols; j++) {\r\n\t\t\t\t// Skip if it was the column to exclude\r\n\t\t\t\tif (j === excludeCol) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Save the old matrix's value at the current row/column to the\r\n\t\t\t\t// new array\r\n\t\t\t\tdata[row][col] = this[i][j];\r\n\r\n\t\t\t\t// Increment cols\r\n\t\t\t\tcol++;\r\n\t\t\t}\r\n\r\n\t\t\t// Increment rows\r\n\t\t\trow++;\r\n\t\t}\r\n\r\n\t\treturn new Matrix(data);\r\n\t};\r\n\r\n\t// Internal: Computes the determinant of a matrix.\r\n\t//\r\n\t// matrix - The matrix to get the determinant of.\r\n\t//\r\n\t// Returns the determinant.\r\n\tfunction determinant(matrix) {\r\n\t\t// Check if the matrix is a 2x2\r\n\t\tif (matrix.rows === 2 && matrix.cols === 2) {\r\n\t\t\treturn (matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]);\r\n\t\t}\r\n\t\t// Otherwise, reduce the size by 1 and recurse\r\n\t\telse {\r\n\t\t\tvar det = 0;\r\n\t\t\tfor (var i = 0; i < matrix.cols; i++) {\r\n\t\t\t\tdet += matrix[0][i] * (i % 2 === 0 ? 1 : -1) * determinant(matrix._submatrix(0, i));\r\n\t\t\t}\r\n\r\n\t\t\treturn det;\r\n\t\t}\r\n\t}\r\n\r\n\t// Public: Computes the determinant of the matrix.\r\n\t//\r\n\t// Throws an error if the matrix does not have the same number of rows as\r\n\t// columns.\r\n\t// Returns the determinant.\r\n\tMatrix.prototype.determinant = function() {\r\n\t\t// Throw an error if the matrix does not have the same number or rows as\r\n\t\t// columns\r\n\t\tif (this.rows !== this.cols) {\r\n\t\t\tthrowError('Cannot compute the determinant of a non-square matrix');\r\n\t\t}\r\n\r\n\t\treturn determinant(this);\r\n\t};\r\n\r\n\t// Public: Multiplies the current matrix by the matrix passed.\r\n\t//\r\n\t// matrix - The matrix to multiply. This can be a Matrix\r\n\t//          object or a two-dimensional array.\r\n\t//\r\n\t// Throws an error if there are invalid dimensions or if the matrix passed\r\n\t// is not a valid Matrix object.\r\n\t// Returns nothing.\r\n\tMatrix.prototype.multiply = function(matrix) {\r\n\t\t// If matrix is an array, convert it to a Matrix\r\n\t\tif (Array.isArray(matrix)) {\r\n\t\t\tmatrix = new Matrix(matrix);\r\n\t\t}\r\n\r\n\t\t// Throw an error if the matrix is not a valid Matrix object\r\n\t\tif (!matrix instanceof Matrix) {\r\n\t\t\tthrowError('Argument passed is not a valid Matrix object');\r\n\t\t}\r\n\r\n\t\t// Throw an error if there are invalid dimensions (matrix one columns\r\n\t\t// must equal matrix two rows)\r\n\t\tif (this.cols !== matrix.rows) {\r\n\t\t\tthrowError('Invalid dimensions');\r\n\t\t}\r\n\r\n\t\t// Create the product matrix\r\n\t\tvar product = new Matrix(this.rows, matrix.cols);\r\n\r\n\t\t// Compute the product\r\n\t\tfor (var row = 0; row < this.rows; row++) {\r\n\t\t\tfor (var col = 0; col < matrix.cols; col++) {\r\n\t\t\t\tvar square = 0;\r\n\r\n\t\t\t\tfor (var i = 0; i < this.cols; i++) {\r\n\t\t\t\t\tsquare += this[row][i] * matrix[i][col];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tproduct[row][col] = square;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this._setData(product);\r\n\t};\r\n\r\n\t// Public: Multiplies each element in the matrix by a scalar.\r\n\t//\r\n\t// c - The scalar to multiply by.\r\n\t//\r\n\t// Throws an error if the scalar is not numeric.\r\n\t// Returns nothing.\r\n\tMatrix.prototype.scalar = function(c) {\r\n\t\t// Throw an error if the scalar is not numeric\r\n\t\tif (typeof c !== 'number') {\r\n\t\t\tthrowError('The scalar must be numeric');\r\n\t\t}\r\n\r\n\t\tfor (var row = 0; row < this.rows; row++) {\r\n\t\t\tfor (var col = 0; col < this.cols; col++) {\r\n\t\t\t\tthis[row][col] *= c;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Computes the sum of two or more matrices.\r\n\t//\r\n\t// Throws an error if the two matrices do not have valid dimensions.\r\n\t// Returns nothing.\r\n\tMatrix.prototype.add = function() {\r\n\t\t// Get all the matrices to add to the current matrix\r\n\t\tvar matrices = Array.prototype.slice.call(arguments, 0);\r\n\r\n\t\t// Save a reference to this\r\n\t\tvar thiz = this;\r\n\r\n\t\t// Add each of the matrices to the current matrix\r\n\t\tmatrices.forEach(function(matrix) {\r\n\t\t\t// Convert matrix to a Matrix object if it is an array\r\n\t\t\tif (Array.isArray(matrix)) {\r\n\t\t\t\tmatrix = new Matrix(matrix);\r\n\t\t\t}\r\n\r\n\t\t\t// Throw an error if the dimensions do not match\r\n\t\t\tif (thiz.rows !== matrix.rows || thiz.cols !== matrix.cols) {\r\n\t\t\t\tthrowError('Matrix dimensions do not match');\r\n\t\t\t}\r\n\r\n\t\t\tfor (var row = 0; row < thiz.rows; row++) {\r\n\t\t\t\tfor (var col = 0; col < thiz.cols; col++) {\r\n\t\t\t\t\tthiz[row][col] += matrix[row][col];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Computes the difference of two or more matrices.\r\n\t//\r\n\t// Throws an error if the two matrices do not have valid dimensions.\r\n\t// Returns nothing.\r\n\tMatrix.prototype.subtract = function(matrix) {\r\n\t\t// Get all the matrices to subtract from the current matrix\r\n\t\tvar matrices = Array.prototype.slice.call(arguments, 0);\r\n\r\n\t\t// Save a reference to this\r\n\t\tvar thiz = this;\r\n\r\n\t\t// Subtract each of the matrices from the current matrix\r\n\t\tmatrices.forEach(function(matrix) {\r\n\t\t\t// Convert matrix to a Matrix object if it is an array\r\n\t\t\tif (Array.isArray(matrix)) {\r\n\t\t\t\tmatrix = new Matrix(matrix);\r\n\t\t\t}\r\n\r\n\t\t\t// Throw an error if the dimensions do not match\r\n\t\t\tif (thiz.rows !== matrix.rows || thiz.cols !== matrix.cols) {\r\n\t\t\t\tthrowError('Matrix dimensions do not match');\r\n\t\t\t}\r\n\r\n\t\t\tfor (var row = 0; row < thiz.rows; row++) {\r\n\t\t\t\tfor (var col = 0; col < thiz.cols; col++) {\r\n\t\t\t\t\tthiz[row][col] -= matrix[row][col];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Raises the matrix to the nth power.\r\n\t//\r\n\t// power - The power to raise the matrix to.\r\n\t//\r\n\t// Throws an error if the power is not an integer greater than one.\r\n\t// Returns nothing.\r\n\tMatrix.prototype.raise = function(power) {\r\n\t\t// Throw an error if the power is not an integer\r\n\t\tif (typeof power !== 'number' || Math.round(power, 0) !== power) {\r\n\t\t\tthrowError('The power must be an integer');\r\n\t\t}\r\n\r\n\t\t// Throw an error if the power is not >= 2\r\n\t\tif (power < 2) {\r\n\t\t\tthrowError('The power must be greater than or equal to 1');\r\n\t\t}\r\n\r\n\t\t// Compute the power\r\n\t\tvar product = this.clone();\r\n\t\twhile (--power) {\r\n\t\t\tproduct.multiply(this);\r\n\t\t}\r\n\r\n\t\treturn this._setData(product);\r\n\t};\r\n\r\n\t// Public: Squares the matrix.\r\n\t//\r\n\t// Returns nothing.\r\n\tMatrix.prototype.square = function() {\r\n\t\tthis.raise(2);\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Cubes the matrix.\r\n\t//\r\n\t// Returns nothing.\r\n\tMatrix.prototype.cube = function() {\r\n\t\tthis.raise(3);\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Computes the inverse of the matrix.\r\n\t//\r\n\t// Returns nothing.\r\n\tMatrix.prototype.inverse = function() {\r\n\t\t// Throw an error if the matrix is either not square or is singular\r\n\t\tif (!this.isSquare() || this.isSingular()) {\r\n\t\t\tthrowError('The matrix must be a square matrix with a size of at least 2x2');\r\n\t\t}\r\n\r\n\t\t// Declare variables\r\n\t\tvar ratio;\r\n\t\tvar a;\r\n\t\tvar n = this.rows;\r\n\r\n\t\t// Put an identity matrix to the right of matrix\r\n\t\tthis.cols = 2 * n;\r\n\t\tfor (var i = 0; i < n; i++) {\r\n\t\t\tfor (var j = n; j < 2 * n; j++) {\r\n\t\t\t\tif (i === (j - n)) {\r\n\t\t\t\t\tthis[i][j] = 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis[i][j] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < n; i++) {\r\n\t\t\tfor (var j = 0; j < n; j++) {\r\n\t\t\t\tif (i !== j) {\r\n\t\t\t\t\tratio = this[j][i] / this[i][i];\r\n\t\t\t\t\tfor (var k = 0; k < 2 * n; k++) {\r\n\t\t\t\t\t\tthis[j][k] -= ratio * this[i][k];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < n; i++) {\r\n\t\t\ta = this[i][i];\r\n\t\t\tfor (var j = 0; j < 2 * n; j++) {\r\n\t\t\t\tthis[i][j] /= a;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Rmove the left-hand identity matrix\r\n\t\tfor (var i = 0; i < n; i++) {\r\n\t\t\tthis[i].splice(0, n);\r\n\t\t}\r\n\t\tthis.cols = n;\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Returns whether or not the current matrix equals\r\n\t// the passed matrix.\r\n\t//\r\n\t// Returns a boolean.\r\n\tMatrix.prototype.equals = function(m) {\r\n\t\t// Convert the argument to a Matrix object if it was an array\r\n\t\tif (Array.isArray(m)) {\r\n\t\t\tm = new Matrix(m);\r\n\t\t}\r\n\r\n\t\t// Return false if the dimensions do not match\r\n\t\tif (this.rows !== m.rows || this.cols !== m.cols) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Check each location\r\n\t\tfor (var row = 0; row < this.rows; row++) {\r\n\t\t\tfor (var col = 0; col < this.cols; col++) {\r\n\t\t\t\tif (this[row][col] !== m[row][col]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\t// Public: Decides whether or not the matrix is square.\r\n\t//\r\n\t// Returns a boolean of whether or not the matrix is square.\r\n\tMatrix.prototype.isSquare = function() {\r\n\t\treturn this.rows === this.cols;\r\n\t};\r\n\r\n\t// Public: Decides whether or not the matrix is a 1x1.\r\n\t//\r\n\t// Returns a boolean of whether or not the matrix is singular.\r\n\tMatrix.prototype.isSingular = function() {\r\n\t\treturn this.rows === 1 && this.cols === 1;\r\n\t};\r\n\r\n\t// Public: Clones the matrix.\r\n\t//\r\n\t// Returns a new Matrix object.\r\n\tMatrix.prototype.clone = function() {\r\n\t\treturn new Matrix(this.toArray());\r\n\t};\r\n\r\n\t// Public: Override Matrix#toJSON() and Matrix#toArray to return a\r\n\t// two-dimensional array with the matrix data.\r\n\t//\r\n\t// Returns a two-dimensional array with the matrix data.\r\n\tMatrix.prototype.toJSON = Matrix.prototype.toArray = function() {\r\n\t\tvar result = [];\r\n\r\n\t\tfor (var row = 0; row < this.rows; row++) {\r\n\t\t\tresult[row] = [];\r\n\r\n\t\t\tfor (var col = 0; col < this.cols; col++) {\r\n\t\t\t\tresult[row][col] = this[row][col];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n\r\n\t// Internal: Sets the matrix's data to the object passed.\r\n\t//\r\n\t// data - A two-dimensional array or Matrix object with the data to set on\r\n\t//        the current object.\r\n\t//\r\n\t// Returns nothing.\r\n\tMatrix.prototype._setData = function(data) {\r\n\t\tvar row, col;\r\n\r\n\t\t// Remove the old data from the matrix\r\n\t\tfor (row = 0; row < this.rows; row++) {\r\n\t\t\tdelete this[row];\r\n\t\t}\r\n\r\n\t\t// Convert the data into a Matrix object if it is an array\r\n\t\tif (Array.isArray(data)) {\r\n\t\t\tdata = new Matrix(data);\r\n\t\t}\r\n\r\n\t\t// Throw an error if data is not a valid Matrix object\r\n\t\tif (!data instanceof Matrix && typeof data !== 'function') {\r\n\t\t\tthrowError('The data to set must be either a Matrix object, a two dimensional array, or a function');\r\n\t\t}\r\n\r\n\t\t// Set the new row and column counts\r\n\t\tif (typeof data !== 'function') {\r\n\t\t\tthis.rows = data.rows;\r\n\t\t\tthis.cols = data.cols;\r\n\t\t}\r\n\r\n\t\t// Set the new data on the matrix\r\n\t\tfor (row = 0; row < this.rows; row++) {\r\n\t\t\tthis[row] = [];\r\n\r\n\t\t\tfor (col = 0; col < this.cols; col++) {\r\n\t\t\t\tthis[row][col] = typeof data === 'function' ? data.call(this, row, col) : data[row][col];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\t// Public: Creates an n by n identity Matrix object.\r\n\t//\r\n\t// n - The height and width of the matrix.\r\n\t//\r\n\t// Returns a new Matrix object.\r\n\tMatrix.identity = function(n) {\r\n\t\t// Create the matrix\r\n\t\tvar m = new Matrix(n, n);\r\n\r\n\t\t// Set the diagonals to one, everything else to 0\r\n\t\treturn m._setData(function(row, col) {\r\n\t\t\treturn row === col ? 1 : 0;\r\n\t\t});\r\n\t};\r\n\r\n\t// Internal: Throws an error if silent is set set to false.\r\n\t//\r\n\t// msg - The error message.\r\n\t//\r\n\t// Returns nothing.\r\n\tfunction throwError(msg) {\r\n\t\tif (!Matrix.silent) {\r\n\t\t\tthrow new Error(msg);\r\n\t\t}\r\n\t}\r\n\r\n\t// Define Matrix for AMD loaders\r\n\tif (typeof define === 'function') {\r\n\t\tdefine(function() {\r\n\t\t\treturn Matrix;\r\n\t\t});\r\n\t}\r\n\t// Expose Matrix for node\r\n\telse if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = Matrix;\r\n\t}\r\n\t// Otherwise write to window\r\n\telse {\r\n\t\twindow.Matrix = Matrix;\r\n\t}\r\n}());"]}